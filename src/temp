int Net_ReceivePacket(client_t* client, header_t* out_header, void* out_data_buffer, int max_buffer_size) {
    uint8_t* buf = client->recv_buf;
    size_t* len = &client->recv_buf_len;

    while (1) {
        // Recv more if needed
        if (*len < sizeof(header_t)) {
            ssize_t r = recv(client->fd, buf + *len, sizeof(header_t) - *len, 0);
            if (r == 0) return -1;  // Disconnect
            if (r < 0) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) return 0;
                return -errno;  // Error
            }
            *len += r;
            if (*len < sizeof(header_t)) return 0;  // Still partial header
        }

        // Peek header (copy to temp to avoid unaligned access if needed)
        header_t temp_hdr;
        memcpy(&temp_hdr, buf, sizeof(header_t));

        size_t total_needed = sizeof(header_t) + temp_hdr.data_size;
        if (temp_hdr.data_size > max_buffer_size) {
            // Invalid: Drain buf or disconnect
            *len = 0;
            return -2;
        }

        // Validate size per type (your existing switch, but on temp_hdr.type)

        if (*len < total_needed) {
            // Recv more for data
            ssize_t r = recv(client->fd, buf + *len, total_needed - *len, 0);
            if (r == 0) return -1;
            if (r < 0) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) return 0;
                return -errno;
            }
            *len += r;
            if (*len < total_needed) return 0;  // Still partial
        }

        // Complete: Copy out
        memcpy(out_header, buf, sizeof(header_t));
        if (temp_hdr.data_size > 0) {
            memcpy(out_data_buffer, buf + sizeof(header_t), temp_hdr.data_size);
        }

        // Shift buffer forward
        memmove(buf, buf + total_needed, *len - total_needed);
        *len -= total_needed;

        return 1;  // Processed one
    }
}
